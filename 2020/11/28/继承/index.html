<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="继承A 对象通过继承B对象，就能直接拥有B对象的所有属性和方法。这对于代码的复用非常有用， JavaScript通过使用“类”（class）和原型对象（prototype）实现。常见的有六种继承方式。 方法一：原型链继承关键在于：**子类型的原型为父类型的一个实例对象。**      让父类的属性和方法在子类实例的原型链上。  CHILD .prototype &#x3D; new PARENT（）；  C">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2020/11/28/%E7%BB%A7%E6%89%BF/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="继承A 对象通过继承B对象，就能直接拥有B对象的所有属性和方法。这对于代码的复用非常有用， JavaScript通过使用“类”（class）和原型对象（prototype）实现。常见的有六种继承方式。 方法一：原型链继承关键在于：**子类型的原型为父类型的一个实例对象。**      让父类的属性和方法在子类实例的原型链上。  CHILD .prototype &#x3D; new PARENT（）；  C">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="d:/木犀/js/blog%20pic/原型继承.png">
<meta property="og:image" content="d:/木犀/js/blog%20pic/寄生组合继承.png">
<meta property="article:published_time" content="2020-11-28T15:25:38.809Z">
<meta property="article:modified_time" content="2020-11-27T17:06:56.515Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="d:/木犀/js/blog%20pic/原型继承.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-继承" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/28/%E7%BB%A7%E6%89%BF/" class="article-date">
  <time datetime="2020-11-28T15:25:38.809Z" itemprop="datePublished">2020-11-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p><strong>A 对象通过继承B对象，就能直接拥有B对象的所有属性和方法。</strong>这对于代码的复用非常有用，</p>
<p>JavaScript通过使用“类”（class）和原型对象（prototype）实现。常见的有六种继承方式。</p>
<h4 id="方法一：原型链继承"><a href="#方法一：原型链继承" class="headerlink" title="方法一：原型链继承"></a>方法一：原型链继承</h4><p>关键在于：**<em>子类型的原型为父类型的一个实例对象。**</em></p>
<img src="D:\木犀\js\blog pic\原型继承.png" alt="avatar"  />



<ul>
<li><p>让父类的属性和方法在子类实例的原型链上。</p>
</li>
<li><p>CHILD .prototype = new PARENT（）；</p>
</li>
<li><p><strong>CHILD .prototype .constructor = CHILD;</strong>(保证原型重定向的完整性)</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Person(name)&#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function Student(species,age)&#123;</span><br><span class="line">    this.species &#x3D; species;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Student.prototype &#x3D; new Person();</span><br><span class="line">Student.prototype.constructor &#x3D; Student;</span><br><span class="line">var studentalin &#x3D; new Student(&quot;大学生&quot;,21);</span><br><span class="line">console.log(studentalin.species);</span><br></pre></td></tr></table></figure>





<p><strong><em>特点：</em></strong></p>
<ol>
<li><p>子类的原型指向父类的实例，故子类的实例可以通过_proto _访问到父类的实例，从而访问到父类的私有方法，再通过 _proto _指向父类的prototype获得父类原型上的方法。从而<strong>将父类的私有公有属性都当做子类的公有属性</strong>。</p>
</li>
<li><p>子类可以重写父类上的方法，但是会导致父类其他的实例受到影响。所以想为子类新增属性和方法，必须要<strong>放在替换原型的语句之后写</strong>。</p>
</li>
<li><p>继承过多，它会连同不需要继承的属性也继承，会造成效率和用法上的障碍</p>
</li>
</ol>
<p>（ps：prototype和proto的区别概念</p>
<p>每个函数都会有一个prototype属性，这个属性是一个指针，指向一个对象，记住只有函数才有,并且通过bind()绑定的也没有。Person.prototype就是原型对象。</p>
<p>![avatar](D:\木犀\js\blog pic\prototype.webp)</p>
<p>proto则是用来将对象与该对象的原型相连。</p>
<p>constructor属性其实就是将原型对象指向关联的构造函数。</p>
<p><code>Person.prototype.constructor ===Person // true</code></p>
<p>）</p>
<h4 id="方法二：借用构造函数继承"><a href="#方法二：借用构造函数继承" class="headerlink" title="方法二：借用构造函数继承"></a>方法二：借用构造函数继承</h4><p>关键在于：<strong>在子类型构造函数中通用call（）或者apply（）调用父类型构造函数。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var A&#x3D;function()&#123; </span><br><span class="line">    this.name&#x3D;&quot;meili&quot;; </span><br><span class="line">    this.show&#x3D;function()&#123; </span><br><span class="line">        alert(this.color); </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">var B&#x3D;function()&#123;</span><br><span class="line">    this.color&#x3D;&quot;red&quot; ;</span><br><span class="line">        A.call(this)&#x2F;&#x2F;a在 b中执行，实现了B继承A的功能。其中的this指向B的实例。</span><br><span class="line">&#125; </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"> var C &#x3D; new B();  &#x2F;&#x2F;B已经继承了A，从而C也拥有了A的属性。</span><br><span class="line"> C.show();  &#x2F;&#x2F;red</span><br></pre></td></tr></table></figure>



<p>call改变函数A 的this指向，使之指向B。</p>
<p><strong><em>特点：</em></strong></p>
<ol>
<li><p>不是真正的继承，只能继承父类的（私有）属性和方法，不能继承父类原型的属性和方法。</p>
</li>
<li><p>代码无法复用。总体而言就是可以<strong>实现所有属性方法独享，但无法做到属性、方法共享</strong>（例如，Sub1新增了一个函数，然后想让Sub2、Sub3…都可以用的话就无法实现了，只能Sub2、Sub3…各自在构造函数中新增）。</p>
</li>
</ol>
<h4 id="方法三：原型链-借用构造函数的组合继承"><a href="#方法三：原型链-借用构造函数的组合继承" class="headerlink" title="方法三：原型链+借用构造函数的组合继承"></a>方法三：原型链+借用构造函数的组合继承</h4><p>关键在于：<strong>利用原型链实现原型属性和方法的继承，从而通过构造函数来实现实例属性的继承(保证每个实例都有单独的实例属性，而不互相影响，将属性和原型分开继承。</strong></p>
<p>![aveter](D:\木犀\js\blog pic\组合继承.png)</p>
<p><strong>特点：</strong></p>
<ol>
<li>可以继承实例属性、方法，也可以继承原型属性、方法</li>
<li>不存在引用属性共享问题</li>
</ol>
<h4 id="优化1："><a href="#优化1：" class="headerlink" title="优化1："></a>优化1：</h4><p><strong>关键：将父类原型和子类原型指向同一对象，子类可以继承到父类的公有方法当做自己的公有方法。</strong></p>
<p><code>Parent.prototype = Student.prototype</code></p>
<p>但是没有办法辨别实例是子类还是父类创造的，子类和父类的构造函数指向是同一个。</p>
<h4 id="优化2-寄生组合式继承："><a href="#优化2-寄生组合式继承：" class="headerlink" title="优化2 寄生组合式继承："></a>优化2 寄生组合式继承：</h4><p><strong>关键：借助原型基于已有的对象创建一个新对象，同时还不必因此创建自定义类型</strong>。</p>
<p><strong><em>利用Object.create(原型)</em></strong></p>
<img src="D:\木犀\js\blog pic\寄生组合继承.png" alt="aveter" style="zoom:100%;" />

<ul>
<li>跟原型链继承有点相似，但是这里并不是创建一个父类的实例然后将子类的原型变为父类的实例，而是通过Object.create创建了一个新的空对象使之指向父类原型，此时空对象中不存在父类的任何私有属性，仅存在父类的公有属性，然后将子类的实例proto指向空对象实现父类公有属性的继承，同时使用call继承父类型的私有属性，从而分开继承私有和公有属性。</li>
</ul>
<p>ps：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Activity()</span><br><span class="line">&#123;</span><br><span class="line">  var x&#x3D;1;&#x2F;&#x2F; var变量定义的是私有属性      &#x2F;&#x2F;类似与private</span><br><span class="line">  this.y&#x3D;2;&#x2F;&#x2F;this关键字定义的是公有属性   &#x2F;&#x2F;类似与public</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>私有属性不能直接访问，而公有属性可以.</strong></p>
</li>
<li><p><strong>用var变量定义的是私有方法，而this定义的是公有方法，可以直接调用.</strong></p>
</li>
</ul>
<h4 id="方法四：用class继承"><a href="#方法四：用class继承" class="headerlink" title="方法四：用class继承"></a>方法四：用class继承</h4><p>Class 之间可以通过extends关键字实现继承</p>
<p><code>class ColorPoint extends Point &#123;&#125;</code></p>
<p>上面代码定义了一个ColorPoint类， 该类通过extends关键字， 继承了Point类的所有属性和方法。 但是由于没有部署任何代码， 所以这两个类完全一样， 等于复制了一个Point类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class ColorPoint extends Point &#123;</span><br><span class="line">	constructor(x, y, color) &#123;</span><br><span class="line">		super(x, y); &#x2F;&#x2F;  调用父类的 constructor(x, y)</span><br><span class="line">		this.color &#x3D; color;</span><br><span class="line">	&#125;</span><br><span class="line">	toString() &#123;</span><br><span class="line">		return this.color + &#39; &#39; + super.toString(); &#x2F;&#x2F;  调用父类的 toString()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>constructor方法和to String方法之中， 都出现了<strong>super关键字</strong>， 它在这里表示父类的构造函数， 用来新建父类的this对象。</p>
</li>
<li><p>子类必须在constructor方法中调用super方法， 否则新建实例时会报错。 这是因为子类没有自己的this对象， 而是继承父类的this对象， 然后对其进行加工。 如果不调用super方法， 子类就得不到this对象。</p>
</li>
<li><p>实质是先创造父类的实例对象this（ 所以必须先调用super方法）， 然后再用子类的构造函数修改this。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/11/28/%E7%BB%A7%E6%89%BF/" data-id="cki1uk3420000tstphjtzfh75" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/12/04/Task%203%EF%BC%9A%E5%AF%B9%E8%B1%A1%EF%BC%8C%E6%95%B0%E7%BB%84%E4%BB%A5%E5%8F%8A%E5%AD%97%E7%AC%A6%E4%B8%B2/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2020/11/27/javascript%20task1&2/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/12/04/Task%203%EF%BC%9A%E5%AF%B9%E8%B1%A1%EF%BC%8C%E6%95%B0%E7%BB%84%E4%BB%A5%E5%8F%8A%E5%AD%97%E7%AC%A6%E4%B8%B2/">(no title)</a>
          </li>
        
          <li>
            <a href="/2020/11/28/%E7%BB%A7%E6%89%BF/">(no title)</a>
          </li>
        
          <li>
            <a href="/2020/11/27/javascript%20task1&2/">(no title)</a>
          </li>
        
          <li>
            <a href="/2020/11/21/%E5%AD%A6%E8%80%8C%E6%9C%BA%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/">(no title)</a>
          </li>
        
          <li>
            <a href="/2020/10/10/%E7%AC%AC%E4%B8%80%E7%AF%87/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>